---
title: "Introduction to Debug Infrastructure"
videoId: "vhSIwxAWDIY"
markers:
    "1:07": "Plan for today"
    "2:34": "Test-driven development doesn't help solving the harder problems of game programming"
    "4:59": "Purpose of debug services"
    "6:33": "1) Coaxing bugs to the surface"
    "8:00": "2) Locating bugs that are clearly present but difficult to pinpoint"
    "11:58": "We'll focus on versatile debug services aimed at solving difficult bugs"
    "13:21": "Logs. Example of debugging framerate problems"
    "15:49": "We could start by recording our debug timers on each frame"
    "16:35": "Simplifying the usage of our debug timers"
    "17:38": "We could combine the log and the looped live code editing replay system"
    "20:01": "Limitations of this approach - Is not particularly good for multithreading problems"
    "21:23": "Necessary components: counter log, replay system, log of memory consumption and diagramming"
    "22:16": "Diagramming"
    "25:57": "We want all the debugging subsystems going through the same log"
    "27:14": "We want to avoid having to change the code in order to debug it..."
    "29:11": "...and also avoid having to remove debug calls once we're done"
    "31:44": "Review of desired features for our debug system"
    "32:56": "Will we need tuning/fiddling support?"
    "36:40": "Let's start building the debug system"
    "38:05": "The old debug cycle counters were lousy on purpose"
    "43:00": "Improving the interface of the cycle counters"
    "43:27": "Abusing constructor/destructor pairs to achieve that better interface"
    "54:49": "We shouldn't need to store values anywhere to make paired calls at the beginning and end of a frame"
    "57:11": "\"I just kind of ruined The Variable\" (!quote 202)"
    "1:01:03": "Review of the inner workings of the new cycle counter interface"
    "1:02:15": "Testing that the code still runs after today's changes"
    "1:02:37": "Q&A"
    "1:03:22": "SoysauceTheKid Q: Is there a way to determine how much overhead the debug takes when it is enabled? (Or is there such a thing as debug levels?)"
    "1:04:48": "Psi9 Q: Why not use a simple template? That would remove storing the ID, e.g. template<int ID> struct timed_block {};"
    "1:05:50": "insofaras Q: Would you agree that there is a similarity between test driven development and \"writing the usage code first\"?"
    "1:06:32": "ChaiLatteQuinoa Q: Would you consider functional programming for game development?"
    "1:08:01": "ingenero Q: How does the StartCycleCount get stored in the struct when you don't explicitly set StartCycleCount = StartCycleCountInit or something what you did with the ID?"
    "1:08:55": "jfcatalan Q: Do you get Heisenbugs, where the bug happens only when there's not any debug code running?"
    "1:10:18": "InstantKafka Q: So the destructor gets called right when it goes out of scope? (!quote 203)"
    "1:14:08": "abnercoimbre Q: Community fight"
    "1:14:25": "Close this down and wrap up another episode of Handmade Hero"
---

## Quotes

* 202\. I just kind of ruined The Variable (57:11)
* 203\. If you are the kind of person who is passionate about C++ because your mother didn't love you as a child, or whatever the other reasons are that people cling onto it, you can spend a bunch of time learning all those things (1:10:18)
