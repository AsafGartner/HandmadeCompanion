---
title: "Converting Math Operations to SIMD"
videoId: "1CVmlnhgT3g"
markers:
    "1:11:08": "Q&A"
    "1:11:32": "kknewkles Q: How do you cover multiple CPU technologies intrinsic-wise? Preprocessor switches on dedicated intrinsics for each? Also, whom to read on ASM? I'm thinking Mike Abrash?"
    "1:13:09": "houb_ Q: We have come from 385 cycles to ~123. Does something like the 80%-20% rule apply? Do you think we will get down to 50 cycles?"
    "1:15:22": "maexono Q: The way we use mmSquare, does it calculate the argument twice?"
    "1:15:41": "Debugger: Determine if the compiler is doing common subexpression elimination for these multiplies"
    "1:21:11": "Deep, concentrated investigation (!quote 86)"
    "1:25:54": "Look at how fast the game's running"
    "1:26:19": "cvaucher Q: Where do OpenCL and other GPGPU frameworks fit into optimization? It seems like if something is SIMD-able, it could just be done wider on a GPU. Are there workloads that are better suited to the CPU and SIMD?"
    "1:29:06": "garlandobloom Q: We have optimizations still on?"
    "1:29:19": "gasto5 Q: Why are there optimizing options in the compiler if one will end up typing SIMD functions?"
    "1:31:01": "quylthulg Q: Do you know of the _mm_setr_ps intrinsic (and _pd etc) - note the r in setr? It loads the values in reverse order, i.e. in the order that is more intuitive"
    "1:31:38": "garlandobloom Q: When do you think we will thread the renderer?"
    "1:31:57": "goodoldmalk Q: Possibly misguided question, is there a way to overload operators to use SIMD instructions instead?"
    "1:32:45": "digitaldomovoi Q: Is padding and alignment still something you have to concern yourself with? I remember doing SIMD in the mid 2000s, and SIMD was essentially worthless (much of the time) if your data wasn't aligned"
    "1:33:43": "digitaldomovoi Q: Addendum: By \"concern yourself\", I mean, is it something the compiler now handles more autonomously when you \"engage\" SIMD"
    "1:34:15": "kil4h Q: Will you generate asm for NEON (if you port to arm of course)? GCC seems to be pretty bad at generating correct code with intrinsics (from my experience on Android)"
    "1:35:03": "culver_fly Q: How would you know if doing something will speed up the code? Especially when it's a fairly large change to the codebase and when time is limited, I find myself reluctant to perform such optimizations in fear of introducing bugs"
    "1:36:46": "miblo Q: What do you think you'll next want to convert to SIMD, in case I want to practise over the weekend?"
    "1:38:52": "flaturated Q: Can you compile it -Od and show how SIMD has helped there?"
    "1:39:32": "kknewkles Q: Would it be a good exercise (albeit a large one) to study a simple CPU and write some soft for it? Arduino or something ancient? I wanted to learn coding for GBA for a while"
    "1:41:04": "kknewkles Q: Let's rephrase: what CPU would you advise to study that would be simple enough yet representative enough of the general stuff you should know about when working with CPUs? (!quote 87)"
    "1:42:52": "theitchyninja Q: How long have you been working on this and when do you think you will finish?"
    "1:43:29": "gasto5 Q:Are you going to optimize gameplay code as well?"
    "1:43:45": "houb_ Q: Have you heard of the JayStation2 Project from Jaymin Kessler, working with the Raspberry Pi 2 B+?"
    "1:44:03": "Close things down with a recap of the week's optimisation work"
    "1:48:03": "Shout out to the mods"
---

## Quotes

* 86\. Sorry I'm not talking more, but... (1:21:11)
* 87\. The important thing is that you build a mental model of the fact that there is a CPU down there (1:41:04)
