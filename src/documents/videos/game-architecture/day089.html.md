---
title: "Renderer Push Buffer Entry Types"
videoId: "lllby5vrEes"
markers:
    "1:34": "Take a look at what happened on Friday"
    "3:56": "Blackboard: Rendering"
    "5:25": "Blackboard: Reasons for using a PushBuffer"
    "6:24": "Blackboard: History of game architecture built around the renderer"
    "7:01": "Blackboard: Modern day luxuries and trade-offs"
    "8:03": "Blackboard: Output Target"
    "9:44": "Blackboard: Balanced approach to optimisation"
    "11:05": "Blackboard: PushBuffer benefits"
    "13:01": "Blackboard: Considerations for supporting multiple targets"
    "14:16": "Blackboard: Our first target: Software 'GPU-esque Rendering'"
    "17:00": "Blackboard: Two ways of looking at a render working: 1) Explicit Surface Rasteriser"
    "18:22": "Blackboard: 2) Implicit Surface Rasteriser"
    "19:39": "Blackboard: Reasons to use the Implicit method"
    "19:56": "Blackboard: Something like how our renderer will look"
    "20:47": "Blackboard: SIMD instruction sets"
    "22:41": "Blackboard: Overview of what we're building"
    "25:02": "Start pulling the Draw functions out"
    "25:25": "Mini-rant on devenv"
    "26:08": "Take a look at where we're at"
    "26:27": "Start playing with the code"
    "26:53": "Vaporise PieceCount"
    "27:06": "Look at adding multiple types of commands in there, starting by renaming entity_visible_piece to render_group_entry"
    "28:09": "Pull RenderGroupToOutput out into handmade_render_group.cpp"
    "30:38": "Compression Oriented Programming"
    "32:21": "Consider operating on groups of entities"
    "34:18": "Setup cases for handling different types of Entry"
    "35:27": "Introduce InvalidDefaultCase"
    "36:05": "Increment BaseAddress depending on the Entry->Type"
    "36:51": "Write those cases"
    "37:53": "Create the corresponding render_entries"
    "39:59": "Describe 'compact discriminated union'"
    "42:23": "Review our new ability"
    "43:57": "Ridiculous Trick: Prepend the type_name with RenderGroupEntryType to make the Identifier, and #define PushRenderElement macro for a type-safe way of correctly setting the type field in one step"
    "45:52": "Pass the Type to PushRenderElement"
    "46:54": "Compile and clean up"
    "47:45": "Check all is still well in-game"
    "47:58": "Create a bitmap type"
    "49:23": "Call the PushPiece function for the bitmap"
    "49:59": "Hit an assertion because the Entry->Bitmap is not filled in"
    "50:10": "Make sure we push a rectangle on when we call the bitmap type"
    "51:10": "Check that all is still okay in-game"
    "51:46": "Compress the code down into something more usable"
    "54:30": "Bake the offsets in to PushRect"
    "58:24": "Pull out the EntityBasis computation"
    "59:58": "Clean up"
    "1:01:32": "See where we're at"
    "1:01:38": "Q&A"
    "1:03:15": "pseudonym73 Q: Warning! There may be lots of prestream questions today"
    "1:03:57": "Q: When you meet a bug in the game and are able to recreate it, will you get a bug line in the programming, or how does it work?"
    "1:04:36": "Q: Is it worth aligning render_entries?"
    "1:05:51": "Q: What is Mantle?"
    "1:06:08": "Q: Any recommendations of some reading about GPUs, rendering, rasterisation, except for a Google search?"
    "1:09:03": "Q: Why use pointers over references?"
    "1:10:31": "Q: About Mantle, were you aware AMD dropped development for it and put a lot of that manpower into helping push Vulkan?"
    "1:11:23": "Q: The PushBuffer is an abstraction layer relying on memory for communication instead of a bunch of functions, if I understand correctly. Is that how you prefer API design in general?"
    "1:13:03": "We are done here"
---
