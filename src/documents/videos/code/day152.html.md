---
title: "New Win32 File API Implementation"
videoId: "hRYrqGBmfOA"
markers:
    "00:00:27": "Recap"
    "00:01:10": "Plan for today"
    "00:02:23": "Asset metadata is already loaded, so LoadBitmap and LoadSound reduce to just fetching the data"
    "00:03:58": "Getting rid of LoadSound"
    "00:06:22": "(intermission) Forcing order of reads between checking if an asset is loaded and accessing it"
    "00:07:57": "(intermission) Implementing CompletePreviousReadsBeforeFutureReads"
    "00:09:55": "Back to removing LoadSound"
    "00:13:34": "Copying the contents of assets into the right place in memory"
    "00:14:21": "General-purpose memory copy function"
    "00:16:21": "Setting the channel sample pointers"
    "00:17:57": "Testing the changes. There's some strange clicking bug going on, probably not related to today's changes. We'll do the debugging later"
    "00:19:41": "Asset background loader with tag matching in 430 lines of code!"
    "00:22:58": "Avoiding loading the entire asset file into memory"
    "00:23:24": "Assets need to be rebased and pointed to the appropriate file through a file index"
    "00:25:16": "Finding a good place in the code for the asset struct"
    "00:27:34": "Filling in the asset struct"
    "00:33:36": "The asset struct is just an hha_asset augmented with a file index"
    "00:35:09": "Don't design architecture up-front"
    "00:36:50": "Implementing GetFileHandleFor"
    "00:39:08": "File I/O code is simple. Assuming we don't get it wrong, we'll save time by writing it now and testing it together with the code we just wrote. The alternative would involve writing some extra test code"
    "00:41:36": "Implementing the platform functions"
    "00:43:23": "We don't close files, so there's no need for a Win32CloseFile function"
    "00:44:05": "Win32OpenFile"
    "00:49:13": "Win32ReadDataFromFile"
    "00:50:21": "Overlapped I/O"
    "00:53:45": "Windows can't do reads bigger than 4GB. We don't plan on reading assets of that size, but let's assert against that situation, just in case"
    "00:55:23": "Win32FileError"
    "00:56:47": "Ignoring file operations on bad handles"
    "00:58:08": "Testing today's code"
    "00:59:09": "Quick step-through"
    "01:00:00": "We hadn't read the header yet!"
    "01:02:14": "Visual Studio fails to show size information on symbols outside the current running executable"
    "01:05:00": "The null asset triggers an assertion. We ignore it for the moment"
    "01:05:46": "It (mostly) works!"
    "01:06:25": "Q&A"
    "01:07:25": "bigmonachus Q: What do you use when you need something more dynamic than arenas? Default to VirtualAlloc/malloc? Something completely different?"
    "01:09:33": "insofaras Q: How \"handmade\" are you going to go on the Linux version?"
    "01:10:50": "quatzequatel Q: Kind of off-topic do you usually have that much luck not getting bugs?"
    "01:13:02": "plain_flavored Q: Do you usually design an API by just implementing it, or do you try to define the interface first?"
    "01:15:49": "kknewkles Q: What is \"usage code\"? Basically everything down the line that awaits to be fed data?"
    "01:27:22": "general_tach Q: Do you feel that a lot of the common programs today have \"bloated\" code (much unnecessary code or something along those lines), and/or that coders need to learn to simplify/barebone their code?"
    "01:27:42": "gasto5 Q: Doesn't anticipating the usage of the API require decades of work?"
    "01:33:14": "kknewkles Q: So basically when you're about to make shoes for a monster, you don't assume how many legs or toes it has, let it stomp around and then use the footprints to make the shoes"
    "01:33:44": "jameswidman Q: Suggestion: call this \"Snuffy-oriented programming\""
---
